#pragma once

#include <cstdint>
#include <optional>
#include <vector>
#include <unordered_map>
#include <queue>

// -----------------------------------------------------------------------------
// Simple single-instrument Limit Order Book (LOB).
//
// Defines core data structures used by a matching engine:
//   - Side   : buy/sell indicator
//   - Order  : client-submitted limit/market order
//   - Trade  : execution record
//   - OrderBook : price–time priority matching engine
//
// This header contains data definitions only.
// -----------------------------------------------------------------------------

namespace lob {

/**
 * @enum Side
 * @brief Order side (Buy or Sell).
 */
enum class Side {
    Buy,  ///< Buy side
    Sell  ///< Sell side
};

/**
 * @brief Returns the opposite side (Buy <-> Sell).
 *
 * @param s The input side.
 * @return The opposite side.
 */
inline Side opposite(Side s) {
    return (s == Side::Buy) ? Side::Sell : Side::Buy;
}

/**
 * @struct Order
 * @brief Represents a client-submitted order.
 *
 * Limit orders must specify a price.
 * Market orders set `price = std::nullopt`.
 */
struct Order {
    std::int64_t          order_id;   ///< Unique order identifier.
    Side                  side;       ///< Buy or Sell.
    std::optional<double> price;      ///< Limit price; nullopt for market orders.
    std::int64_t          quantity;   ///< Remaining unfilled quantity.
    std::int64_t          timestamp;  ///< Submission timestamp (ns/us).
};

/**
 * @struct Trade
 * @brief Execution record generated by matching two orders.
 *
 * Execution price always follows the resting-order price rule.
 */
struct Trade {
    std::int64_t buy_order_id;   ///< ID of the buy order.
    std::int64_t sell_order_id;  ///< ID of the sell order.
    double       price;          ///< Execution price.
    std::int64_t quantity;       ///< Executed quantity.
    std::int64_t timestamp;      ///< Match timestamp.
};



/**
 * @struct OrderNode
 * @brief Node in the doubly linked list representing a single resting order.
 *
 * Each node stores:
 *  - The order itself
 *  - prev pointer (toward older orders)
 *  - next pointer (toward newer orders)
 *
 * Used to support O(1) insertion and cancellation.
 */
struct OrderNode {
    Order      order;           ///< The resting order stored at this node.
    OrderNode* prev = nullptr;  ///< Previous node in the FIFO queue.
    OrderNode* next = nullptr;  ///< Next node in the FIFO queue.
};


/**
 * @struct PriceLevel
 * @brief FIFO queue of resting orders at a single price level.
 *
 * Implements a doubly linked list (head = oldest order, tail = newest).
 */
struct PriceLevel {
    OrderNode* head = nullptr;  ///< Pointer to the oldest resting order.
    OrderNode* tail = nullptr;  ///< Pointer to the most recent resting order.
};


/**
 * @class OrderBook
 * @brief Core limit order book implementation using price–time priority.
 *
 * Matching rules:
 *  - Better prices are matched first.
 *  - Within the same price level, orders match in FIFO order.
 *
 * Internal data structures:
 *  - bids_/asks_          : price -> PriceLevel (FIFO queue of resting orders)
 *  - bid_heap_/ask_heap_  : heaps for fast best-bid / best-ask lookup
 *  - order_map_           : order_id -> OrderInfo for O(1) cancellation
 *
 * The public API mirrors the Python version, while leveraging efficient C++
 * data structures for O(1) cancellation and O(log n) best-price queries.
 */
class OrderBook {

public:
    using Price    = double;        ///< Price type for orders and trades.
    using Quantity = std::int64_t;  ///< Quantity type (integer units).
    using OrderId  = std::int64_t;  ///< Unique order identifier.

    // -------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------

    /**
     * @brief Add a limit order and immediately match against the opposite side.
     *
     * If order_id is not supplied, a new monotonic ID is generated.
     *
     * @param side     Buy or Sell.
     * @param price    Limit price.
     * @param quantity Order quantity.
     * @param order_id Optional externally supplied order ID.
     * @param ts_ns    Optional timestamp in nanoseconds.
     *
     * @return The assigned order ID.
     */
    OrderId addLimitOrder(
        Side side,
        Price price,
        Quantity quantity,
        std::optional<OrderId> order_id   = std::nullopt,
        std::optional<std::int64_t> ts_ns = std::nullopt
    );

    /**
     * @brief Add a market order (no price limit).
     *
     * The order matches against resting orders until fully filled or the book is
     * empty. Any remaining quantity is discarded (market orders never rest).
     *
     * @param side     Buy or Sell.
     * @param quantity Order quantity.
     * @param order_id Optional externally supplied order ID.
     * @param ts_ns    Optional timestamp in nanoseconds.
     *
     * @return The assigned order ID.
     */
    OrderId addMarketOrder(
        Side side,
        Quantity quantity,
        std::optional<OrderId> order_id   = std::nullopt,
        std::optional<std::int64_t> ts_ns = std::nullopt
    );

    /**
     * @brief Cancel an existing resting order.
     *
     * Removes the order from its price level queue and the internal maps.
     *
     * @param id Order ID to cancel.
     *
     * @return true if the order was cancelled, false if not found or already filled.
     */
    bool cancelOrder(OrderId id);

    /**
     * @brief Return the best bid as (price, total_quantity).
     *
     * @return std::nullopt if no bids exist.
     */
    std::optional<std::pair<Price, Quantity>> bestBid() const;

    /**
     * @brief Return the best ask as (price, total_quantity).
     *
     * @return std::nullopt if no asks exist.
     */
    std::optional<std::pair<Price, Quantity>> bestAsk() const;

    /**
     * @brief Get the top N price levels on a given side (best to worst).
     *
     * @param side   Buy or Sell.
     * @param levels Maximum number of levels to return.
     *
     * @return Vector of (price, total_quantity).
     */
    std::vector<std::pair<Price, Quantity>>
    getDepth(Side side, std::size_t levels = 5) const;

    /**
     * @brief Access the list of all trades executed so far.
     *
     * @return Reference to internal trade log.
     */
    const std::vector<Trade>& trades() const noexcept { return trades_; }

    /**
     * @brief Reset the book: remove all orders, trades, and price levels.
     */
    void clear();

private:
    // -------------------------------------------------------------------------
    // Internal Types
    // -------------------------------------------------------------------------

    /** @brief Mapping from price → PriceLevel. */
    using PriceMap = std::unordered_map<Price, PriceLevel>;

    /** @brief Max-heap for bid prices. */
    using PriceQueue = std::priority_queue<Price>;

    /** @brief Min-heap for ask prices (via greater<> comparator). */
    using MinPriceQueue =
        std::priority_queue<Price, std::vector<Price>, std::greater<Price>>;

    /**
     * @struct OrderInfo
     * @brief Metadata stored for each active order to support O(1) cancel.
     *
     * Contains:
     *  - side  : Buy or Sell
     *  - price : Resting price level
     *  - node  : Pointer to the linked-list node that holds the order
     */
    struct OrderInfo {
        Side       side;   ///< Buy or Sell.
        Price      price;  ///< Resting price.
        OrderNode* node;   ///< Node containing the order.
    };

    // -------------------------------------------------------------------------
    // Internal State
    // -------------------------------------------------------------------------

    PriceMap bids_;   ///< Bid-side price → FIFO queue of orders.
    PriceMap asks_;   ///< Ask-side price → FIFO queue of orders.

    PriceQueue    bid_heap_; ///< Max-heap for best-bid lookup.
    MinPriceQueue ask_heap_; ///< Min-heap for best-ask lookup.

    std::unordered_map<OrderId, OrderInfo>
        order_map_; ///< Active order metadata for O(1) cancel.

    std::vector<Trade> trades_; ///< Log of executed trades.

    OrderId next_order_id_ = 1; ///< Monotonic order ID generator.

private:
    // -------------------------------------------------------------------------
    // Internal Helpers (defined in order_book.cpp)
    // -------------------------------------------------------------------------

    PriceMap&       book(Side side);
    const PriceMap& book(Side side) const;

    /**
     * @brief Add a price level to the appropriate heap.
     */
    void pushPrice(Price price, Side side);

    /**
     * @brief Return best price without removing it (lazy cleanup applied).
     */
    std::optional<Price> peekBestPrice(Side side) const;

    /**
     * @brief Pop and return best price, ensuring the level has liquidity.
     */
    std::optional<Price> popBestPrice(Side side);

    /**
     * @brief Sum the total resting quantity at a given price level.
     */
    static Quantity sumLevelQuantity(const PriceLevel& level);

    /**
     * @brief Generate the next unused order ID.
     */
    OrderId nextFreeId();

    /**
     * @brief Core matching routine for an incoming order.
     */
    void matchIncoming(Order& incoming);

    /**
     * @brief Add a remaining (unmatched) portion of an order to the book.
     */
    void addRestingOrder(const Order& order);

    /**
     * @brief Record a trade event between two orders.
     */
    void recordTrade(const Order& incoming,
                     const Order& resting,
                     Price price,
                     Quantity qty);
};


} // namespace lob
